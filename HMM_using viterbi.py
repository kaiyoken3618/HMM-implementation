# -*- coding: utf-8 -*-
"""150204018_Soft_Computing_Assignment_1____HMM.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1fZJW-2AsgVETWmUwzxnvWGO2YREO3Yug

LOAD INPUT
HERE SAMPLE_DATASET TAKES TRAINING DATA AS AN INPUT
"""

from google.colab import drive
drive.mount('/content/drive')
main_directory = '/content/drive/My Drive/118/training_Dragon_1000.data.txt'
main_directory1 = '/content/drive/My Drive/118/testing_Dragon_1000.data.txt' 
drive.mount("/content/drive", force_remount=True)

from google.colab import drive
drive.mount('/content/drive') 
drive.mount("/content/drive", force_remount=True)

import pandas as pd
import numpy as np
import io
def input_data(sample_dataset):
  columns = ['state', 'result']
  train_data = pd.read_csv(sample_dataset, names = columns, sep = '\t', header = None)
  return train_data

"""FOR EMISSION MATRIX
>CALCULATE THE PROBABILITY OF DIFFERENT TEST SAMPLE AND STORED IN EMMISION MATRIX
"""

def emission_matrix_calculate(trainData):
  fw, fl, cw, cl = 0, 0, 0, 0
  for ind, row in trainData.iterrows():
    if row['state'] == 'fair' and row['result'] == 'win':
      fw += 1
    elif row['state'] == 'fair' and row['result'] == 'lose':
      fl += 1
    elif row['state'] == 'cheat' and row['result'] == 'win':
      cw += 1
    elif row['state'] == 'cheat' and row['result'] == 'lose':
      cl += 1
  emission_matrix = [[fw/(fw+fl), fl/(fw+fl)], [cw/(cw+cl), cl/(cw+cl)]]
  return emission_matrix

"""FOR TRANSITION MATRIX
> CALCULATE THE PROBABILITY OF DIFFERENT STATE TRANSITION FOR TRAINING DATA
 AND VALUE STORED IN TRANSITION MATRIX FOR FURTHER CALCULATION
"""

def transition_matrix_count(trainData):
  statelist = list(trainData['state'])
  ff, fc, cc, cf = 0, 0, 0, 0
  count = len(statelist)
  for i in range(count-1):
    if statelist[i] == 'fair' and statelist[i+1] == 'fair':
      ff += 1
    elif statelist[i] == 'fair' and statelist[i+1] == 'cheat':
      fc += 1
    elif statelist[i] == 'cheat' and statelist[i+1] == 'cheat':
      cc += 1
    elif statelist[i] == 'cheat' and statelist[i+1] == 'fair':
      cf += 1

  transition_matrix = [[ff/(ff+fc) , fc/(ff+fc)],[cc/(cf+cc) , cf/(cf+cc)]]
  return transition_matrix

"""INPUT_OBSERVATION FUNCTION TAKES TESTING DATA SET"""

def input_observation(testingData):
  with open(testingData, 'r') as rfile:
    ln = rfile.readlines()
    observ = [l.strip() for l in ln]
    return observ

"""IMPLEMENT HMM USING THE VITERBI ALGORITHM
>Reference:
Murphy, Kevin P. Machine Learning: A Probabilistic Perspective. MIT press, 2012.

![alt text](https://drive.google.com/uc?id=1J9yuHGxAKhbX67x_lmFylPzeZAKkm7Ns)
"""

from decimal import Decimal
def viterbi(observations, emission_matrix, initial_pro, transition_matrix):
  ob_count = len(observations)
  R = [[],[]]
  final_output = ''
  score = 0; 
  hishab1=0; 
  hishab2=0;
  for i in range(ob_count):
    if i == 0:
      if observations[i] == 'win':
        R[0].append(Decimal(initial_pro[0]) * Decimal(emission_matrix[0][0]))
        R[1].append(Decimal(initial_pro[1]) * Decimal(emission_matrix[1][0]))
      elif observations[i] == 'lose':
        R[0].append(Decimal(initial_pro[0]) * Decimal(emission_matrix[0][1]))
        R[1].append(Decimal(initial_pro[1]) * Decimal(emission_matrix[1][1]))
    else:
      if observations[i] == 'win':
        R[0].append(Decimal(emission_matrix[0][0]) * max(R[0][i-1]*Decimal(transition_matrix[0][0]), R[1][i-1]*Decimal(transition_matrix[1][0])))
        R[1].append(Decimal(emission_matrix[1][0]) * max(R[0][i-1]*Decimal(transition_matrix[0][1]), R[1][i-1]*Decimal(transition_matrix[1][1])))
      elif observations[i] == 'lose':
        R[0].append(Decimal(emission_matrix[0][1]) * max(R[0][i-1]*Decimal(transition_matrix[0][0]), R[1][i-1]*Decimal(transition_matrix[1][0])))
        R[1].append(Decimal(emission_matrix[1][1]) * max(R[0][i-1]*Decimal(transition_matrix[0][1]), R[1][i-1]*Decimal(transition_matrix[1][1])))

    if R[0][i] >= R[1][i] : 
      hishab1=hishab1+1
      final_output  = final_output + 'F -> '
      score = R[0][i]
    elif R[1][i] >= R[0][i] : 
      hishab2=hishab2+1
      final_output  = final_output + 'C -> '
      score = R[1][i]
   
  return score, final_output,hishab1,hishab2

"""MAIN FUNCTION"""

import math
def main():

    sample_dataset = main_directory
    testing_data = main_directory1 

    observations = input_observation(testing_data)
    initial_pro = np.array([0.5, 0.5])

    trainData = input_data(sample_dataset)

    emission_matrix = emission_matrix_calculate(trainData)
    transition_matrix = transition_matrix_count(trainData)

    print("Transition Matrix:\n", transition_matrix)
    print("Emission Matrix:\n", emission_matrix)

    score, final_output,hishab1,hishab2 = viterbi(observations, emission_matrix, initial_pro, transition_matrix)
    print('\n')
    print('Final output:\n', final_output)
    print('Score:\n', score)  
    print('fair:',hishab1)  
    print('cheat:',hishab2) 
    
    


main()

